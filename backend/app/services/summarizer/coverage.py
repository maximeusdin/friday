"""
Server-Generated Coverage Line

The coverage line is ALWAYS generated by the server from metadata - NOT by the LLM.
This removes a common failure path and ensures accuracy.
"""

from typing import Optional

from .models import SelectionInputs, CoverageInfo


def generate_coverage_info(
    chunks_summarized: int,
    candidate_pool_size: int,
    total_hits: int,
    selection_inputs: SelectionInputs,
    retrieval_mode: str,
    cap_applied: bool,
    threshold_used: Optional[float] = None,
) -> CoverageInfo:
    """
    Generate coverage information from metadata.
    
    Server-generated - NOT from LLM output.
    
    Args:
        chunks_summarized: Number of chunks in the summary
        candidate_pool_size: How many chunks were considered (scored)
        total_hits: Total in result set after retrieval filters
        selection_inputs: Selection metadata
        retrieval_mode: "conversational" or "thorough"
        cap_applied: Whether retrieval cap was applied
        threshold_used: Score threshold if applicable
    
    Returns:
        CoverageInfo with all fields populated
    """
    # Build selection notes
    notes_parts = []
    notes_parts.append(f"max_per_doc={selection_inputs.effective_max_per_doc}")
    
    if selection_inputs.doc_focus_mode in ("single_doc", "small_corpus"):
        notes_parts.append(f"mode={selection_inputs.doc_focus_mode}")
    
    if selection_inputs.overrides:
        for key, override in selection_inputs.overrides.items():
            if isinstance(override, dict) and "reason" in override:
                notes_parts.append(override["reason"])
    
    notes_parts.append("soft diversity caps applied")
    
    selection_notes = "; ".join(notes_parts)
    
    # Build not_checked message
    not_reviewed = total_hits - chunks_summarized
    if not_reviewed > 0:
        not_checked = f"Remaining {not_reviewed:,} chunks not reviewed"
    else:
        not_checked = "All matching chunks reviewed"
    
    return CoverageInfo(
        chunks_summarized=chunks_summarized,
        candidate_pool_size=candidate_pool_size,
        total_hits=total_hits,
        selection_policy=selection_inputs.lambdas.get("doc", 0) > 0 and "greedy_soft_diversity" or "greedy_selection",
        doc_focus_mode=selection_inputs.doc_focus_mode,
        summary_type=selection_inputs.summary_type,
        selection_notes=selection_notes,
        not_checked=not_checked,
        retrieval_mode=retrieval_mode,
        cap_applied=cap_applied,
        threshold_used=threshold_used,
    )


def format_coverage_line(coverage: CoverageInfo) -> str:
    """
    Generate human-readable coverage line for display.
    
    Example:
    "Selected 35 from a candidate pool of 5,000 (of 12,847 total hits). 
     Remaining 12,812 chunks not reviewed."
    """
    return (
        f"Selected {coverage.chunks_summarized} from a candidate pool of "
        f"{coverage.candidate_pool_size:,} (of {coverage.total_hits:,} total hits). "
        f"{coverage.not_checked}"
    )
